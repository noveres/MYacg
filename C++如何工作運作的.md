
### 1. **源碼編寫**

* **撰寫**：開發者使用文本編輯器撰寫包含類別、函數、變數等的 C++ 程式碼，這些源碼文件的副檔名通常是 `.cpp`。
- **結構**：C++ 程式會依據程式語法編寫，主要包括物件導向設計（類別、繼承、多型等）、函數、變數等
- **宣告**： 在C++中，任何文字與符號都需要**宣告**，告訴編譯器某個變量、函數或類別的存在，但不一定要給它實際的**定義**或初始化。例如，

```C++
int x;    // 宣告 x 為int變量
int y = 5;  // 宣告並定義int變量 y 賦值為 5
```

*編譯器會為被宣告的內容分配記憶體，用以初始化或調用。因此被宣告的對象只能出現一次。*

>**宣告（declaration）**：告訴編譯器某個變數、函數或類別的存在，但不一定要給它實際的內容或初始化。例如，外部變數和函數原型可以宣告多次。
>**定義（definition）**：不僅告訴編譯器該元素存在，還提供了具體的初始化或實作，這樣編譯器就會為它分配記憶體。定義只能出現一次。


* **外部變數** 和 **函數原型** 可以被宣告多次，但只能被定義一次。

##### 外部變數（`extern`）
當變數被聲明為 `extern` 時，它告訴編譯器該變數在其他地方已經被定義過了，所以在這裡僅僅是宣告，而不是分配新的記憶體空間或進行初始化。外部變數可以在多個檔案中宣告，但是在一個檔案中只能定義一次。

```cpp
// 檔案1: 定義變量
int globalVar = 10; // 定義並初始化 globalVar

// 檔案2: 宣告變量
extern int globalVar; // 宣告，但不定義
```

在檔案2中，我們使用 `extern` 關鍵字來宣告變數 `globalVar`，這告訴編譯器這個變數已經在其他地方定義了。

##### 函數原型
函數原型告訴編譯器某個函數的名稱、參數類型和回傳類型，這樣編譯器就可以知道如何調用該函數。函數原型可以宣告多次（例如在多個檔案中），但同樣函數只能定義一次。

```cpp
// 宣告函數原型（可以多次宣告）
int add(int a, int b); 

// 定義函數（只能定義一次）
int add(int a, int b) {
    return a + b;
}
```

這意味著：
- **函數宣告** 可以放在多個檔案中，讓編譯器知道這個函數的存在。
- **函數定義** 則只能在一個檔案中出現一次，因為它包括了具體的實作。



### 2. **編譯（Compilation）**
   - **預處理器**：在編譯之前，預處理器會首先執行一些指令，如處理 `#include`、`#define` 等預處理器指令，這是第一個階段。
     - 例如：`#include <iostream>` 告訴編譯器引入 iostream 庫。
   - **編譯器**：預處理過後的程式碼進入編譯器，編譯器將源碼轉換成**中間的機器語言指令**或**目標碼**。這是將高階語言轉換為底層指令的過程。每個 C++ 函數或類別會被分解為相應的機器指令。
     - 編譯器通常會檢查語法錯誤並報告錯誤訊息。
   - **生成目標文件**：編譯後會生成 `.o` 或 `.obj` 之類的目標文件，它包含了二進位的機器碼，但還沒有完全獨立執行。

### 3. **連結（Linking）**
   - **靜態/動態連結**：在連結階段，目標文件會與所需的外部庫（如 C++ 標準庫 `libstdc++`）和其他模組進行連結。連結器負責將不同的目標文件、函數和庫進行整合，生成一個最終的可執行文件。
     - **靜態連結**：外部庫會在連結階段被整合到最終的可執行檔中。
     - **動態連結**：外部庫（如 `.dll` 或 `.so` 文件）不會被嵌入到可執行檔，而是在執行時動態載入。

### 4. **執行（Execution）**
   - **加載器（Loader）**：當執行可執行文件時，操作系統的加載器將可執行文件載入到記憶體中，準備執行。加載器同時會載入所需的動態庫。
   - **執行程式碼**：可執行文件包含了具體的機器指令，CPU 會按照這些指令逐步執行，進而實現程式的功能。例如，當程式呼叫某個函數時，CPU 會依據連結器提供的位址執行相應的程式碼段。

### 5. **記憶體管理**
   - C++ 中的變數和物件會在記憶體中分配，依據不同的作用域和生命週期進行管理：
     - **堆（Heap）**：開發者可以手動分配和釋放記憶體（如使用 `new` 和 `delete`）。
     - **棧（Stack）**：局部變數會在函數結束時自動釋放，這些變數儲存在棧中。
     - **靜態區**：全局變數和靜態變數則存放在靜態區域，直到程式結束時才會釋放。

### 6. **物件導向與多型機制運作**
   - **類別與物件**：C++ 程式中物件的創建和銷毀通常會呼叫構造函數和析構函數，管理物件的初始化和清理。
   - **多型（Polymorphism）**：透過虛函數表（vtable），C++ 支援運行時多型，這使得一個基類指標可以指向派生類的物件，並動態呼叫派生類中覆蓋的虛函數。

### 7. **優化與效率**
   - C++ 編譯器通常會進行大量的優化，比如內聯函數、循環展開、常數折疊等，以提升程式執行的效能。開發者也可以手動進行底層的優化，通過直接控制記憶體或使用運算符重載來提高程式的效率。

